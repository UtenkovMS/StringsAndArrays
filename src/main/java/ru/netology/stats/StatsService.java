package ru.netology.stats;

public class StatsService {

    public long sumSales(long[] sales) {
        long sumSales = 0; // первый элемент массива под индексом 0, т.е {80000, ...}
        for (int i = 0; i < sales.length; i++) { // перебирает элементы массива по порядку в пределах массива
            sumSales = sumSales + sales[i]; // Данное выражение запускает счетчик. К начальному элементу под индексом 0 прибавляет следующее значение из массива
        }
        return sumSales;
    }

    public double averageSales(long[] sales) {

        double sumSales = 0; // первый элемент массива под индексом 0, т.е {80000, ...}
        for (int i = 0; i < sales.length; i++) { // перебирает элементы массива по порядку в пределах массива
            sumSales = sumSales + sales[i]; // Данное выражение запускает счетчик. К начальному элементу под индексом 0 прибавляет следующее значение из массива
        }

        double averageSales; // средняя сумма значений
        averageSales = (long) sumSales / sales.length; // сумма значений делится на количество значений массива
        return averageSales;
    }

    public long maxMonthSales(long[] sales) {

        int maxMonth = 0; // первый элемент массива под индексом 0, т.е {80000, ...}
        for (int i = 0; i < sales.length; i++) { // перебирает элементы массива по порядку в пределах массива
            if (sales[i] >= sales[maxMonth]) { // условие: если текущее значение i больше или равно предыдущего, то условие выполняется
                maxMonth = i; // Если условие выполняется, то i принимает значение из массива.
            }
        }
        return maxMonth + 1; // месяцы нумеруются с 1, а индексы массива с 0, нужно выровнять значение на 1
    }


    public long minMonthSales(long[] sales) {

        int minMonth = 0; // первый элемент массива под индексом 0, т.е {80000, ...}
        for (int i = 0; i < sales.length; i++) { // перебирает элементы массива по порядку в пределах массива
            if (sales[i] <= sales[minMonth]) { // условие: если текущее значение i меньше или равно предыдущего, то условие выполняется
                minMonth = i; // Если условие выполняется, то i принимает значение из массива.
            }
        }
        return minMonth + 1; // месяцы нумеруются с 1, а индексы массива с 0, нужно выровнять значение на 1
    }

    public long salesBelowAverage(long[] sales) {

        double averageSales = averageSales(sales); // вызов метода расчета средних продаж

        int belowAverage = 0; // первый элемент массива под индексом 0, т.е {8, ...}
        for (int i = 0; i < sales.length; i++) {// перебирает элементы массива по порядку в пределах массива
            if (sales[i] < averageSales) // условие: выбирает элемент массива ниже среднего значения в пределах массива
                belowAverage = belowAverage + 1; // Данное выражение запускает счетчик. Согласно условию к индексу, у которого элемент ниже среднего значения, будет прибавлен следующий индекс с элементом ниже среднего значения.

        }

        return belowAverage;
    }

    public long salesMoreAverage(long[] sales) {

        double averageSales = averageSales(sales); // вызов метода расчета средних продаж
        int moreAverage = 0; // первый элемент массива под индексом 0, т.е {80000, ...}
        for (int i = 0; i < sales.length; i++) {// перебирает элементы массива по порядку в пределах массива
            if (sales[i] >= averageSales) // условие: выбирает элемент массива выше среднего значения в пределах массива
                moreAverage = moreAverage + 1; // Данное выражение запускает счетчик. Согласно условию к индексу, у которого элемент выше среднего значения, будет прибавлен следующий индекс с элементом выше среднего значения.
        }

        return moreAverage;

    }
}

